# Анализ состояния подшипника с использованием машинного обучения

Этот проект представляет собой систему для определения состояния подшипника на основе анализа FFT (быстрого преобразования Фурье) звуковых сигналов с использованием нейронных сетей.

## 🎯 Цель проекта

Создать модель машинного обучения, которая может:
- Определять состояние подшипника в процентах (0-100%)
- Показывать процент износа подшипника
- Использовать MPS (Metal Performance Shaders) для ускорения обучения
- Обрабатывать данные FFT с timestamp и частотами
- Сохранять и загружать обученные модели для повторного использования

## 📁 Структура проекта

```
bearing-signal/
├── main.py                          # Основной файл запуска
├── models.py                        # Модели нейронных сетей
├── dataset.py                       # Загрузка и обработка данных
├── training.py                      # Функции обучения и оценки
├── prediction.py                    # Функции предсказания
├── visualization.py                 # Визуализация результатов
├── model_visualization.py           # Визуализация архитектуры модели
├── utils.py                         # Утилиты и настройки
├── predict_with_saved_model.py      # Скрипт для предсказаний с сохраненной моделью
├── requirements.txt                 # Зависимости
├── README.md                        # Документация
├── data/                            # Папка с данными
│   ├── bad_bearing(0).csv           # Данные плохого подшипника (0%)
│   ├── normal_bearing(0.5).csv      # Данные нормального подшипника (50%)
│   ├── new_bearing(1).csv           # Данные нового подшипника (100%)
│   └── test_bearing.csv             # Тестовые данные для предсказания
├── saved_models/                    # Папка с сохраненными моделями
│   ├── bearing_classifier.pth       # Сохраненная модель PyTorch
│   ├── scaler.pkl                   # Сохраненный StandardScaler
│   ├── pca.pkl                      # Сохраненный PCA
│   └── model_metadata.pkl           # Метаданные модели
└── visualizations/                  # Папка с визуализациями
    ├── bearing_analysis_results.png # Результаты анализа
    └── trained_model_architecture.png # Архитектура модели
```

## 🚀 Установка и запуск

### 1. Установка зависимостей
```bash
pip install -r requirements.txt
```

### 2. Обучение и сохранение модели
```bash
python main.py
```

### 3. Использование сохраненной модели для предсказаний
```bash
python predict_with_saved_model.py
```

### 4. Визуализация архитектуры модели
```bash
python model_visualization.py
```

## 💾 Сохранение и загрузка моделей

### Автоматическое сохранение
При запуске `main.py` модель автоматически сохраняется в папку `saved_models/`:
- `bearing_classifier.pth` - веса модели PyTorch
- `scaler.pkl` - нормализатор данных (StandardScaler)
- `pca.pkl` - компоненты PCA для уменьшения размерности
- `model_metadata.pkl` - метаданные модели

### Загрузка модели для предсказаний
```python
from utils import load_saved_model

# Загрузка сохраненной модели
model, scaler, pca, metadata = load_saved_model("saved_models")

# Использование для предсказаний
if model is not None:
    # Ваш код для предсказаний
    pass
```

### Использование сохраненной модели
```python
from predict_with_saved_model import predict_with_saved_model

# Анализ нового файла данных
predict_with_saved_model("path/to/your/data.csv")
```

## 🎨 Визуализация модели

### Автоматическая визуализация
При запуске `main.py` автоматически создается визуализация обученной модели в папке `visualizations/`:
- `trained_model_architecture.png` - графическая визуализация архитектуры
- `bearing_analysis_results.png` - результаты анализа с графиками

### Ручная визуализация
```bash
python model_visualization.py
```

Создает следующие файлы:
- `model_architecture.png` - визуализация базовой архитектуры
- `saved_model_architecture.png` - визуализация сохраненной модели
- `model_diagram.txt` - текстовая диаграмма архитектуры

### Архитектура модели
```
Входной слой (100 признаков после PCA)
    ↓
┌─────────────────────────────────────┐
│ Linear(100 → 256)                  │
│ ReLU                               │
│ BatchNorm1d(256)                   │
│ Dropout(0.3)                       │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ Linear(256 → 128)                  │
│ ReLU                               │
│ BatchNorm1d(128)                   │
│ Dropout(0.3)                       │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ Linear(128 → 64)                   │
│ ReLU                               │
│ BatchNorm1d(64)                    │
│ Dropout(0.2)                       │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ Linear(64 → 32)                    │
│ ReLU                               │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ Linear(32 → 1)                     │
│ Sigmoid                            │
└─────────────────────────────────────┘
    ↓
Выход (0-1, масштабируется до 0-100%)
```

### Статистика модели
- **Всего параметров**: 70,017
- **Обучаемых параметров**: 70,017
- **Слоев**: 17 (включая активации и нормализацию)
- **Входной размер**: 100 признаков (после PCA)
- **Выход**: 1 значение (0-100%)

## 📊 Описание данных

### Файлы данных в папке `data/`:

#### Обучающие данные:
- **`bad_bearing(0).csv`** - Данные плохого подшипника (0%)
  - Состояние: критический износ, требует немедленной замены
  - Используется для обучения модели распознавания неисправного состояния
  
- **`normal_bearing(0.5).csv`** - Данные нормального подшипника (50%)
  - Состояние: средний износ, нормальная эксплуатация
  - Используется для обучения модели распознавания нормального состояния
  
- **`new_bearing(1).csv`** - Данные нового подшипника (100%)
  - Состояние: отличное, минимальный износ
  - Используется для обучения модели распознавания нового состояния

#### Тестовые данные:
- **`test_bearing.csv`** - Тестовые данные для предсказания
  - Используется для проверки работы обученной модели
  - Позволяет оценить качество предсказаний на новых данных

### Формат CSV файлов:
- **Первый столбец**: timestamp (время)
- **Первая строка**: частоты (Hz)
- **Остальные данные**: значения FFT для каждой частоты
- **Разделитель**: точка с запятой (;)
- **Размер файлов**: ~2.1MB каждый

### Метки состояний:
- **0%** - Плохой подшипник (требует замены)
- **50%** - Нормальный подшипник (средний износ)
- **100%** - Новый подшипник (отличное состояние)

## 🧠 Архитектура модели

### Нейронная сеть:
- **Входной слой**: 100 признаков (после PCA)
- **Скрытые слои**: 256 → 128 → 64 → 32 нейронов
- **Активации**: ReLU + BatchNorm + Dropout
- **Выход**: 1 нейрон с Sigmoid (масштабируется до 0-100%)

### Предобработка данных:
1. Загрузка трех типов данных: плохой (0%), нормальный (50%), новый (100%) подшипник
2. Удаление timestamp и строки с частотами
3. Обработка NaN значений
4. Замена запятых на точки в десятичных числах
5. Добавление меток классов (0.0, 50.0, 100.0)
6. Объединение всех данных в единый датасет
7. Разделение на обучающую (80%) и тестовую (20%) выборки
8. Нормализация (StandardScaler)
9. Уменьшение размерности (PCA до 100 компонент)

## ⚡ Ускорение обучения

Модель автоматически использует:
- **MPS** (Metal Performance Shaders) на Apple Silicon
- **CUDA** на NVIDIA GPU
- **CPU** как fallback

## 📈 Результаты

### Метрики модели:
- **Точность**: 97.58%
- **Precision/Recall**: 0.98/0.98 (среднее)
- **Объясненная дисперсия PCA**: 60.18%

### Пример вывода:
```
Результат предсказания для test_bearing.csv:
Среднее предсказание: 16.55%
Состояние подшипника: Плохой (0.0%)
Процент износа подшипника: 83.45%
```

## 📋 Модули

### `models.py`
- `BearingClassifier`: Нейронная сеть для классификации состояния подшипника

### `dataset.py`
- `BearingDataset`: PyTorch датасет для данных подшипника
- `load_and_preprocess_data()`: Загрузка и предобработка данных
- `prepare_data_loaders()`: Подготовка DataLoader для обучения
- `process_numeric_data()`: Обработка числовых данных

### `training.py`
- `get_device()`: Определение устройства (MPS/CUDA/CPU)
- `train_model()`: Обучение модели с валидацией
- `evaluate_model()`: Оценка модели на тестовых данных

### `prediction.py`
- `predict_test_bearing()`: Предсказание состояния для новых данных

### `visualization.py`
- `visualize_results()`: Создание графиков и диаграмм результатов

### `model_visualization.py`
- Создание визуализации архитектуры модели

### `utils.py`
- `set_seeds()`: Установка seed для воспроизводимости
- `print_summary()`: Вывод итогового резюме
- `print_model_summary()`: Подробный самари по модели
- `load_saved_model()`: Загрузка сохраненной модели и препроцессоров

### `predict_with_saved_model.py`
- `predict_with_saved_model()`: Выполнение предсказаний с сохраненной моделью

## 🔧 Настройки

### Основные параметры:
- **Эпохи обучения**: 100
- **Размер батча**: 32
- **Learning rate**: 0.001
- **PCA компоненты**: 100
- **Размер тестовой выборки**: 20%

### Пороги классификации:
- **< 25%**: Плохой подшипник
- **25-75%**: Нормальный подшипник
- **> 75%**: Новый подшипник

## 📊 Визуализация

Модель создает файл `bearing_analysis_results.png` с:
1. Графиком потерь (обучающая и тестовая)
2. Графиком точности
3. Матрицей ошибок
4. Распределением предсказаний

## 🤝 Использование

### Для анализа новых данных:
1. Поместите CSV файл с данными в папку `data/`
2. Обновите путь в `predict_with_saved_model.py`
3. Запустите `python predict_with_saved_model.py`

### Для изменения модели:
1. Отредактируйте архитектуру в `models.py`
2. Настройте гиперпараметры в `training.py`
3. Перезапустите обучение с `python main.py`

### Для собственных данных:
1. Убедитесь, что данные в формате CSV с разделителем ";"
2. Первый столбец должен содержать timestamp
3. Первая строка должна содержать частоты
4. Остальные данные - значения FFT

## 📦 Зависимости

Основные библиотеки:
- `torch>=2.0.0` - PyTorch для глубокого обучения
- `torchvision>=0.15.0` - Компьютерное зрение для PyTorch
- `numpy>=1.21.0` - Численные вычисления
- `pandas>=1.3.0` - Обработка данных
- `scikit-learn>=1.0.0` - Машинное обучение
- `matplotlib>=3.5.0` - Визуализация
- `seaborn>=0.11.0` - Статистическая визуализация
- `visualtorch>=0.2.4` - Визуализация архитектуры

## 🔍 Требования к данным

### Формат входных данных:
- CSV файл с разделителем ";"
- Первый столбец: timestamp
- Первая строка: частоты в Hz
- Остальные ячейки: значения FFT

### Пример структуры:
```csv
timestamp;100;200;300;...
2024-01-01 10:00:00;0.123;0.456;0.789;...
2024-01-01 10:00:01;0.234;0.567;0.890;...
```

## 📝 Лицензия

Этот проект предназначен для образовательных и исследовательских целей.